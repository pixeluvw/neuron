import 'package:recase/recase.dart';

import '../generators/model_generator.dart';

/// Templates for model generation
class ModelTemplates {
  /// Model class template with JSON serialization
  static String modelDart(String modelName, List<ModelField> fields) {
    final rc = ReCase(modelName);
    final className = rc.pascalCase;

    final fieldDeclarations =
        fields.map((f) => '  final ${f.dartType} ${f.name};').join('\n');

    final constructorParams = fields.map((f) {
      if (f.isNullable) {
        return '    this.${f.name},';
      } else {
        return '    required this.${f.name},';
      }
    }).join('\n');

    final copyWithParams =
        fields.map((f) => '    ${f.dartType} ${f.name},').join('\n');
    final copyWithBody = fields
        .map((f) => '      ${f.name}: ${f.name} ?? this.${f.name},')
        .join('\n');

    final fromJsonBody =
        fields.map((f) => _generateFromJsonField(f)).join('\n');
    final toJsonBody =
        fields.map((f) => "      '${f.name}': ${f.name},").join('\n');

    final equalsBody = fields
        .map((f) => '          ${f.name} == other.${f.name}')
        .join(' &&\n');
    final hashCodeBody = fields.map((f) => f.name).join(', ');
    final toStringBody = fields.map((f) => '${f.name}: \$${f.name}').join(', ');

    return '''
import 'dart:convert';

/// ${rc.pascalCase} model class
/// 
/// Generated by Neuron CLI
class $className {
  const $className({
$constructorParams
  });

$fieldDeclarations

  /// Create a copy with modified fields
  $className copyWith({
$copyWithParams
  }) {
    return $className(
$copyWithBody
    );
  }

  /// Create from JSON map
  factory $className.fromJson(Map<String, dynamic> json) {
    return $className(
$fromJsonBody
    );
  }

  /// Create from JSON string
  factory $className.fromJsonString(String jsonString) {
    return $className.fromJson(json.decode(jsonString) as Map<String, dynamic>);
  }

  /// Convert to JSON map
  Map<String, dynamic> toJson() {
    return {
$toJsonBody
    };
  }

  /// Convert to JSON string
  String toJsonString() => json.encode(toJson());

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is $className &&
$equalsBody;
  }

  @override
  int get hashCode => Object.hash($hashCodeBody);

  @override
  String toString() => '$className($toStringBody)';
}
''';
  }

  static String _generateFromJsonField(ModelField field) {
    final jsonKey = "'${field.name}'";

    switch (field.type) {
      case 'int':
        if (field.isNullable) {
          return '      ${field.name}: json[$jsonKey] as int?,';
        }
        return '      ${field.name}: json[$jsonKey] as int,';

      case 'double':
        if (field.isNullable) {
          return '      ${field.name}: (json[$jsonKey] as num?)?.toDouble(),';
        }
        return '      ${field.name}: (json[$jsonKey] as num).toDouble(),';

      case 'bool':
        if (field.isNullable) {
          return '      ${field.name}: json[$jsonKey] as bool?,';
        }
        return '      ${field.name}: json[$jsonKey] as bool,';

      case 'String':
        if (field.isNullable) {
          return '      ${field.name}: json[$jsonKey] as String?,';
        }
        return '      ${field.name}: json[$jsonKey] as String,';

      case 'DateTime':
        if (field.isNullable) {
          return '      ${field.name}: json[$jsonKey] != null ? DateTime.parse(json[$jsonKey] as String) : null,';
        }
        return '      ${field.name}: DateTime.parse(json[$jsonKey] as String),';

      default:
        // For complex types, assume they have fromJson
        if (field.isNullable) {
          return '      ${field.name}: json[$jsonKey] != null ? ${field.type}.fromJson(json[$jsonKey] as Map<String, dynamic>) : null,';
        }
        return '      ${field.name}: ${field.type}.fromJson(json[$jsonKey] as Map<String, dynamic>),';
    }
  }
}
